<!DOCTYPE html><html>
<head>
  <meta charset="UTF-8"> 
  <title>Global Game Jam – Hackers</title>
  <!--link rel="icon" href="favicon.png" type="image/png" />
  <link rel="shortcut icon" href="favicon.png" type="image/png" /-->
  <style type="text/css">
    html, body {
      margin: 0;
    }
    #container {
      position: relative;
    }
    #hacking-tool {
      position: absolute;
      display: none;
      margin: 0 auto;
      left: 200px;
      top: 450px;
      width: 400px;
      height: 100px;
    }
    #hacking-tool textarea {
      display: block;
      width: 100%;
    }
    #hacking-tool button {
      display: block;
    }
    #code {
      border: 0;
      width: 100%
    }
    
  </style>
 </head>

<body>

<div id="container">
  <div id="hacking-tool">
    <textarea id="code"></textarea>
    <button id="run-button">Run</button>
  </div>
  <canvas id="canvas" width="800" height="600"></canvas>
</div>

<script type="text/javascript">

// chrome/safari compatiblity
if(!window.KeyEvent) {
  window.KeyEvent = {
    DOM_VK_LEFT:  0x25,
    DOM_VK_RIGHT: 0x27,
    DOM_VK_UP:    0x26,
    DOM_VK_DOWN:  0x28,
    DOM_VK_SPACE:	32
  };
}

Math.radians = function(degrees) {
  return degrees/360.0*(Math.PI*2);
}

Math.degrees = function(radians) {
  return radians/(Math.PI*2)*360.0;
}

var canvas = document.getElementById("canvas");
var ctx = canvas.getContext("2d");

function drawCircle(x, y, size) {
  ctx.beginPath();
  ctx.arc(x, y, size, 0, Math.PI*2, true); 
  ctx.closePath();
  ctx.stroke();
}

function drawPolygon(poly) {
  ctx.beginPath();
  ctx.moveTo(poly[0], poly[1]);
  for(var i=2; i<poly.length; i+=2) {
    ctx.lineTo(poly[i], poly[i+1]);
  }
  ctx.lineTo(poly[0], poly[1]);
  ctx.stroke();
}

// adapted from: http://jsfromhell.com/math/is-point-in-poly
function isPointInPoly(px, py, poly) {
  for(var c = false, i = -1, l = poly.length/2, j = l - 1; ++i < l; j = i)
    ((poly[(i*2)+1] <= py && py < poly[(j*2)+1]) || (poly[(j*2)+1] <= py && py < poly[(i*2)+1]))
      && (px < (poly[j*2] - poly[i*2]) * (py - poly[(i*2)+1]) / (poly[(j*2)+1] - poly[(i*2)+1]) + poly[i*2])
      && (c = !c);
  return c;
}

function isPointInCircle(px, py, cx, cy, csize) {
  var vx = px-cx;
  var vy = py-cy;
  return Math.sqrt((vx*vx)+(vy*vy)) < csize;
}

function determinant(a, b, c, d) {
  return (a*d)-(b*c);
}

// http://stackoverflow.com/questions/1560492/how-to-tell-whether-a-point-is-to-the-right-or-left-of-a-line
// result < 0 point is left of the line
// result == 0 point is on the line
// result > 0 point is right of the line
function orderOfPointAndLine(px, py, ax, ay, bx, by) {
  return determinant(bx-ax, by-ay, px-ax, py-ay);
}

function isPointInArc(px, py, ax, ay, asize, astart, aend) {
  if(!isPointInCircle(px, py, ax, ay, asize)) {
    return false;
  }
  // http://stackoverflow.com/questions/1638437/given-an-angle-and-length-how-do-i-calculate-the-coordinates
  var bx = ax + asize * Math.cos(astart);
  var by = ay + asize * Math.sin(astart);

  if(orderOfPointAndLine(px, py, ax, ay, bx, by) < 0) { // point is left of start
    return false;
  }
  
  bx = ax + asize * Math.cos(aend);
  by = ay + asize * Math.sin(aend);

  if(orderOfPointAndLine(px, py, ax, ay, bx, by) > 0) { // point is right of end
    return false
  }
  return true;
}

// http://fitzgeraldnick.com/weblog/26/
function toArray(obj) {
    return Array.prototype.slice.call(obj);
}
function bind(scope, fn) {
  return function () {
    return fn.apply(scope, toArray(arguments));
  };
}

var Player = {
  x: 0,
  y: 0,
  draw: function() {
    drawCircle(this.x, this.y, 10);
  },
  update: function() {
    var new_x = this.x;
    var new_y = this.y;
	  if (KeyEvent.DOM_VK_UP in keysDown) {
      new_y--;
    }
    if (KeyEvent.DOM_VK_DOWN in keysDown) {
      new_y++;
    }
    if (KeyEvent.DOM_VK_LEFT in keysDown) {
      new_x--;
    }
    if (KeyEvent.DOM_VK_RIGHT in keysDown) {
      new_x++;
    }
    
    if(isPointInPoly(new_x, this.y, Level.walkable)) {
      this.x = new_x;
    }
    if(isPointInPoly(this.x, new_y, Level.walkable)) {
      this.y = new_y;
    }

  }
};

var Cameras = {
  cameras: [],
  create: function(x, y, size, angle_start, angle_end, speed, fn) {
    var camera = {x: x, y:y, size:size, angle_start:angle_start, angle_end:angle_end, speed:speed}
    camera["fn"]=bind(camera, fn);
    this.cameras.push(camera);
  },
  draw: function() {
    for(var i=0; i<this.cameras.length; i++) {
      ctx.beginPath();
      ctx.moveTo(this.cameras[i].x, this.cameras[i].y);
      ctx.arc(this.cameras[i].x, this.cameras[i].y, this.cameras[i].size, this.cameras[i].angle_start, this.cameras[i].angle_end, false);
      ctx.closePath();
      if(this.cameras[i].hasCollision) {
        ctx.strokeStyle = "red";
      }
      ctx.stroke();
      ctx.strokeStyle = "black";
    }
  },
  update: function() {
    for(var i=0; i<this.cameras.length; i++) {
      if(this.cameras[i].fn) {
        this.cameras[i].fn();
      }
      //if player is inside, change flag
      if(isPointInArc(Player.x, Player.y, this.cameras[i].x, this.cameras[i].y, this.cameras[i].size, this.cameras[i].angle_start, this.cameras[i].angle_end)) {
        this.cameras[i].hasCollision = true;
      } else {
        this.cameras[i].hasCollision = false;
      }
    }
  }
}

var Terminals = {
  regions: new Array(),
  functions: new Array(),
  create: function(poly, fn) {
    this.regions.push(poly);
    this.functions.push(fn);
  },
  update: function() {
    if (KeyEvent.DOM_VK_SPACE in keysDown) {
      for(var i=0; i<this.regions.length; i++) {
        if(isPointInPoly(Player.x, Player.y, this.regions[i])) {
          HackTool.show(this.functions[i].toString());
          break;
        }
      }
    }
  },
  draw: function() {
    for(var i=0; i<this.regions.length; i++) {
      drawPolygon(this.regions[i]);
    }
  }
};

var HackTool = {
  isEnabled: false,
  container: undefined,
  button: undefined,
  textarea: undefined,
  init: function() {
    this.container = document.getElementById("hacking-tool");
    this.textarea = document.getElementById("code");
    this.button = document.getElementById("run-button");
    
    this.button.addEventListener("click", function (e) {
      eval("("+HackTool.textarea.value+")()");
      HackTool.hide(); // xxx: add a close button instead??
    });
  },
  show: function(code) {
    this.isEnabled = true;
    this.textarea.value = code;
    this.container.style.display = "block";
  },
  hide: function() {
    this.container.style.display = "none";
    this.isEnabled = false;
  }
};

var Level = {
  draw: function() {
    drawPolygon(this.walkable);
  },
  load: function(filename) {
    var xhr = new XMLHttpRequest();
    xhr.open("GET", filename, false);
    xhr.send();
    xmlDoc = xhr.responseXML;
    
    // parse player
    var elm = xmlDoc.getElementById("player");
    Player.x = elm.cx.baseVal.value;
    Player.y = elm.cy.baseVal.value;
    
    // parse walkable area
    elm = xmlDoc.getElementById("walkable");
    Level.walkable = new Array();
    for(var i=0; i<elm.points.length; i++) {
      Level.walkable.push(elm.points[i].x);
      Level.walkable.push(elm.points[i].y);
    }
    
    // parse cameras
    elm = xmlDoc.getElementsByTagName("svg")[0].childNodes;
    for(var i=0; i<elm.length; i++) {
      if(elm[i].id && elm[i].id.indexOf("camera")==0) {
        var script = elm[i].getAttribute("hackers:camera-script");
        script = script.replace("&gt;", ">");
        script = script.replace("&lt;", "<");
        
        Cameras.create(
          parseFloat(elm[i].getAttribute("sodipodi:cx")),
          parseFloat(elm[i].getAttribute("sodipodi:cy")),
          parseFloat(elm[i].getAttribute("sodipodi:rx")),
          parseFloat(elm[i].getAttribute("sodipodi:start")),
          parseFloat(elm[i].getAttribute("sodipodi:end")),
          parseFloat(elm[i].getAttribute("hackers:camera-speed")),
          eval("("+script+")")
        );
      }
    }
    // todo: parse the rest
  }
};

// Handle keyboard controls (http://www.lostdecadegames.com/how-to-make-a-simple-html5-canvas-game/)
var keysDown = {};

addEventListener("keydown", function (e) {
  if(HackTool.isEnabled) return true;
  
	keysDown[e.keyCode] = true;
	if(!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
    e.preventDefault();
  }
}, false);

addEventListener("keyup", function (e) {
	delete keysDown[e.keyCode];
	if(!e.altKey && !e.ctrlKey && !e.metaKey && !e.shiftKey) {
    e.preventDefault();
  }
}, false);

function init() {
  Level.load("level1 copy.svg");
  /*
  // hardcoded level 1
  Cameras.create(190,149,133.667, 45, 22.5, 0.2, function() {
    if(this.direction<45-(22.5/2) || this.direction>90-(22.5/2)) this.speed=-this.speed;
    this.direction+=this.speed;
  });
  Cameras.create(534,149,137.666, 150, 15, 0.1, function() {
    if(this.direction<150 || this.direction>150+20) this.speed=-this.speed;
    this.direction+=this.speed;
  });
  Cameras.create(534,440,158.334, -135, 25, 0.1, function() {
    if(this.direction<-135 || this.direction>-90-(45/2)) this.speed=-this.speed;
    this.direction+=this.speed;
  });
  Cameras.create(303.5,251,146.833, 55, 25, 0.1, function() {
    if(this.direction<45-22.5 || this.direction>90-22.5) this.speed=-this.speed;
    this.direction+=this.speed;
  });
  */
  Terminals.create([312.333,404.333, 312.333+49.667,404.333, 312.333+49.667,404.333+28, 312.333,404.333+28], function() {
    alert("Hello World!");
  });
  
  HackTool.init();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  Level.draw();
  Cameras.update();
  Cameras.draw();
  Terminals.update();
  Terminals.draw();
  Player.update();
  Player.draw();
}

init();
var timerID = setInterval(draw, 10);

</script>

</body>
</html>